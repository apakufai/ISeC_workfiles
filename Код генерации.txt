
        # СОЗДАНИЕ PDF
        temp_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'temp')
        os.makedirs(temp_dir, exist_ok=True)  # Создаем папку temp, если она не существует
        pdf_filename = f'ИКС-файл {userId}.pdf'  # Имя файла PDF
        # Абсолютный путь к директории, где находится файл шрифта
        base_dir = os.path.dirname(os.path.abspath(__file__))
        # Полный путь к файлу шрифта
        font_path = os.path.join(base_dir, 'static', 'fonts', 'Bahnschrift.ttf')
        # Проверка на существование файла шрифта
        if not os.path.isfile(font_path):
            return f"Файл шрифта не найден по пути: {font_path}", 404
        # Регистрация шрифта
        pdfmetrics.registerFont(TTFont('Bahnschrift', font_path))
        # Указываем полный путь к файлу в папке temp
        pdf_path = os.path.join(temp_dir, pdf_filename)
        
        # Создание холста
        can = canvas.Canvas(pdf_path, pagesize=A4)  # pdf_path для сохранения
        width, height = A4  # Размеры страницы
        can.setFont("Bahnschrift", 14)  # Установка шрифта и его размера


        # СТРАНИЦА 1
        image_path_1 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_1.png")
        # Проверяем, существует ли изображение
        if not os.path.exists(image_path_1):
            print(f"Изображение {image_path_1} не найдено.")
        # Добавляем изображение на страницу
        can.drawImage(image_path_1, 0, 0, width=width, height=height)

        if userId and userId.strip():  # Проверяем, что поле не пустое
            can.drawString(75, (height - 696.345), str(userId))
        else:
            print("userId пустое или None, текст не будет напечатан.")

        if userName and userName.strip():
            can.drawString(89.7, (height - 713.149), str(userName))
        else:
            print("userName пустое или None, текст не будет напечатан.")

        if userSurname and userSurname.strip():
            can.drawString(122.5, (height - 730.049), str(userSurname))
        else:
            print("userSurname пустое или None, текст не будет напечатан.")

        if userBirthyear and userBirthyear.strip():
            can.drawString(163.838, (height - 746.764), str(userBirthyear))
        else:
            print("userBirthyear пустое или None, текст не будет напечатан.")

        if userCategory and userCategory.strip():
            can.drawString(129.7, (height - 763.5), str(userCategory))
        else:
            print("userCategory пустое или None, текст не будет напечатан.")

        if userEmail and userEmail.strip():
            can.drawString(124.2, (height - 780.3), str(userEmail))
        else:
            print("userEmail пустое или None, текст не будет напечатан.")
        # Завершение первой страницы
        can.showPage()


        # СТРАНИЦА 2
        image_path_2 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_2.png")
        # Проверяем, существует ли изображение
        if not os.path.exists(image_path_2):
            print(f"Изображение {image_path_2} не найдено.")
        # Добавляем изображение на страницу
        can.drawImage(image_path_2, 0, 0, width=width, height=height)
            # Функция рисования личного результата на горизонтальной шкале
        def rangeResultHorizontal(range_name, range_x_start, range_x_end, range_y_start, range_divisionsCount):
            # Вычисляем координаты X для "палочки"
            x_start = range_x_start + (((range_x_end - range_x_start) / range_divisionsCount) * range_name)
            y_start = height - range_y_start
            xLeft = -4
            xRight = 4
            yTop = 20
            yCenter = 16
            yBottom = 12
            # Рисуем круг диаметром 1 пункт
            can.setFillColorRGB(0, 0, 0) # Устанавливаем цвет заливки (черный)
            circle_radius = 0.5  # Радиус круга в пунктах
            can.circle(x_start, y_start, circle_radius, stroke=0, fill=1)  # Рисуем круг
            # Рисуем "палочку"
            can.setStrokeColorRGB(0, 0, 0)  # Устанавливаем цвет линии (черный)
            can.setLineWidth(1)  # Устанавливаем ширину линии
            # Рисуем линию (палочку)
            can.line(x_start, y_start, x_start, y_start + yBottom)
            # Рисуем остальные элементы
            can.line(x_start, y_start + yBottom, x_start + xLeft, y_start + yCenter)
            can.circle(x_start + xLeft, y_start + yCenter, circle_radius, stroke=0, fill=1)
            can.line(x_start + xLeft, y_start + yCenter, x_start, y_start + yTop)
            can.circle(x_start, y_start + yTop, circle_radius, stroke=0, fill=1)
            can.line(x_start, y_start + yTop, x_start + xRight, y_start + yCenter)
            can.circle(x_start + xRight, y_start + yCenter, circle_radius, stroke=0, fill=1)
            can.line(x_start + xRight, y_start + yCenter, x_start, y_start + yBottom)
        if adaptation_1 is not None:
            rangeResultHorizontal(adaptation_1, 69.033, 526.35, 517.673, 15)
        else:
            print("adaptation_1 пустое или None, текст не будет напечатан.")
        if compromise_1 is not None:
            rangeResultHorizontal(compromise_1, 69.033, 526.35, 754.016, 15)
        else:
            print("compromise_1 пустое или None, текст не будет напечатан.")
        # Завершение второй страницы
        can.showPage()


        # СТРАНИЦА 3
        image_path_3 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_3.png")
        if not os.path.exists(image_path_3):
            print(f"Изображение {image_path_3} не найдено.")
            return
        can.drawImage(image_path_3, 0, 0, width=width, height=height)
        if bidding_1 is not None:
            rangeResultHorizontal(bidding_1, 69.033, 526.35, 187.427, 15)
        if threat_1 is not None:
            rangeResultHorizontal(threat_1, 69.033, 526.35, 406.91, 15)
        if logicArgument_1 is not None:
            rangeResultHorizontal(logicArgument_1, 69.033, 526.35, 626.394, 15)
        can.showPage()  # Завершение третьей страницы


        # СТРАНИЦА 4
        image_path_4 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_4.png")
        if not os.path.exists(image_path_4):
            print(f"Изображение {image_path_4} не найдено.")
            return
        can.drawImage(image_path_4, 0, 0, width=width, height=height)
        if emotionsArgument_1 is not None:
            rangeResultHorizontal(emotionsArgument_1, 69.033, 526.35, 237.834, 15)
        # Идеальный профиль
        start_x_left = 141.732
        start_y_left = height - 785.197
        end_y_left = height - 484.996
        width_left = 141.732
        fullHeight_left = start_y_left - end_y_left
        values_left = [
            {"name": "Эмоции", "color": (133/255, 85/255, 85/255), "value": 5},
            {"name": "Логика", "color": (118/255, 102/255, 171/255), "value": 10},
            {"name": "Угроза", "color": (138/255, 171/255, 78/255), "value": 8},
            {"name": "Торги", "color": (200/255, 65/255, 85/255), "value": 13},
            {"name": "Компромисс", "color": (90/255, 127/255, 174/255), "value": 10},
            {"name": "Приспособление", "color": (235/255, 188/255, 109/255), "value": 4},
        ]
        current_y_left = start_y_left # Начальная позиция по Y для рисования каждой части графика в цикле for
        for part_left in values_left:
            if part_left["value"] > 0: # Проверяем, что значение больше 0
                # Рассчитываем высоту на основе значения
                height_left = (fullHeight_left * part_left["value"]) / sum(part["value"] for part in values_left)
                can.setStrokeColorRGB(*part_left["color"])
                can.setLineWidth(width_left)
                can.line(start_x_left, current_y_left, start_x_left, current_y_left - height_left)
                current_y_left -= height_left
        # Ваш профиль
        start_x_right = 453.543
        start_y_right = height - 785.197
        end_y_right = height - 484.996
        width_right = 141.732
        fullHeight_right = start_y_right - end_y_right
        values_right = [
            {"name": "Эмоции", "color": (133/255, 85/255, 85/255), "value": emotionsArgument_1},
            {"name": "Логика", "color": (118/255, 102/255, 171/255), "value": logicArgument_1},
            {"name": "Угроза", "color": (138/255, 171/255, 78/255), "value": threat_1},
            {"name": "Торги", "color": (200/255, 65/255, 85/255), "value": bidding_1},
            {"name": "Компромисс", "color": (90/255, 127/255, 174/255), "value": compromise_1},
            {"name": "Приспособление", "color": (235/255, 188/255, 109/255), "value": adaptation_1},
        ]
        current_y_right = start_y_right # Начальная позиция по Y для рисования каждой части графика в цикле for
        for part_right in values_right:
            if part_right["value"] > 0: # Проверяем, что значение больше 0
                # Рассчитываем высоту на основе значения
                height_right = (fullHeight_right * part_right["value"]) / sum(part["value"] for part in values_right)
                can.setStrokeColorRGB(*part_right["color"])
                can.setLineWidth(width_right)
                can.line(start_x_right, current_y_right, start_x_right, current_y_right - height_right)
                current_y_right -= height_right
        can.showPage()  # Завершение четвёртой страницы

        
        # СТРАНИЦА 5
        image_path_5 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_5.png")
        if not os.path.exists(image_path_5):
            print(f"Изображение {image_path_5} не найдено.")
            return
        can.drawImage(image_path_5, 0, 0, width=width, height=height)
        can.setFont("Bahnschrift", 14)  # Устанавливаем шрифт и размер
        if adaptation_2 is not None:  # Проверяем, что adaptation_2 не None
            can.drawString(230, (height - 254.286), str(adaptation_2))  # Печатаем текст (ДЧ)
        else:
            print("adaptation_2 пустое или None, текст не будет напечатан.")
        if compromise_2 is not None:  # Проверяем, что compromise_2 не None
            can.drawString(190.113, (height - 287.886), str(compromise_2))  # Печатаем текст (П)
        else:
            print("compromise_2 пустое или None, текст не будет напечатан.")
        if threat_2 is not None:  # Проверяем, что threat_2 не None
            can.drawString(189, (height - 321.5), str(threat_2))  # Печатаем текст (Б)
        else:
            print("threat_2 пустое или None, текст не будет напечатан.")
        if cooperation_2 is not None:  # Проверяем, что cooperation_2 не None
            can.drawString(187.463, (height - 271.111), str(cooperation_2))  # Печатаем текст (В)
        else:
            print("cooperation_2 пустое или None, текст не будет напечатан.")
        if avoidance_2 is not None:  # Проверяем, что avoidance_2 не None
            can.drawString(196.658, (height - 304.686), str(avoidance_2))  # Печатаем текст (Р)
        else:
            print("avoidance_2 пустое или None, текст не будет напечатан.")
        # Параметры для линии
        can.setStrokeColorRGB(199 / 255, 65 / 255, 84 / 255)
        can.setLineWidth(5)
        can.setFillColorRGB(199 / 255, 65 / 255, 84 / 255)
        # Координаты точек
        soulman_x, soulman_y = 179.528, height - 424.016
        virtuoso_x, virtuoso_y = 429.921, height - 424.016
        politician_x, politician_y = 304.724, height - 549.212
        resident_x, resident_y = 179.528, height - 674.409
        berserker_x, berserker_y = 429.921, height - 674.409
        # Отступы
        axial_hei = 15 # Высота холма вертикальных линий
        axial_wid = 40 # Ширина пика холма вертикальных линий
        diagSmall_hei = 10 # Высота холма малых диагональных линий
        diagSmall_wid = 30 # Ширина пика холма малых диагональных линий
        diagBig_hei = 30 # Высота холма больших диагональных линий
        diagBig_wid = 100 # Ширина пика холма больших диагональных линий
        # Параметры оконечника стрелки
        arrow_length = 30  # Длина "крыльев" стрелки
        arrow_angle = math.radians(15)  # Угол в радианах
        # Душа-человек -> Виртуоз
        def soulman_to_virtuoso():
            can.line(soulman_x, soulman_y, ((soulman_x + virtuoso_x) / 2) - axial_wid, ((soulman_y + virtuoso_y) / 2) + axial_hei)
            can.circle(((soulman_x + virtuoso_x) / 2) - axial_wid, ((soulman_y + virtuoso_y) / 2) + axial_hei, 2.5, stroke=0, fill=1)
            can.line(((soulman_x + virtuoso_x) / 2) - axial_wid, ((soulman_y + virtuoso_y) / 2) + axial_hei, ((soulman_x + virtuoso_x) / 2) + axial_wid, ((soulman_y + virtuoso_y) / 2) + axial_hei)
            can.circle(((soulman_x + virtuoso_x) / 2) + axial_wid, ((soulman_y + virtuoso_y) / 2) + axial_hei, 2.5, stroke=0, fill=1)
            can.line(((soulman_x + virtuoso_x) / 2) + axial_wid, ((soulman_y + virtuoso_y) / 2) + axial_hei, virtuoso_x, virtuoso_y)
            # Координаты конца третьей линии
            line_end_x = ((soulman_x + virtuoso_x) / 2) + axial_wid
            line_end_y = ((soulman_y + virtuoso_y) / 2) + axial_hei
            can.line(line_end_x, line_end_y, virtuoso_x, virtuoso_y)
            # Вычисление направления линии
            dx = virtuoso_x - line_end_x
            dy = virtuoso_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = virtuoso_x
            arrow_tip_y = virtuoso_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(virtuoso_x, virtuoso_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(virtuoso_x, virtuoso_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)
        # Виртуоз -> Душа-человек
        def virtuoso_to_soulman():
            can.line(virtuoso_x, virtuoso_y, ((soulman_x + virtuoso_x) / 2) + axial_wid, ((soulman_y + virtuoso_y) / 2) - axial_hei)
            can.circle(((soulman_x + virtuoso_x) / 2) + axial_wid, ((soulman_y + virtuoso_y) / 2) - axial_hei, 2.5, stroke=0, fill=1)
            can.line(((soulman_x + virtuoso_x) / 2) + axial_wid, ((soulman_y + virtuoso_y) / 2) - axial_hei, ((soulman_x + virtuoso_x) / 2) - axial_wid, ((soulman_y + virtuoso_y) / 2) - axial_hei)
            can.circle(((soulman_x + virtuoso_x) / 2) - axial_wid, ((soulman_y + virtuoso_y) / 2) - axial_hei, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((soulman_x + virtuoso_x) / 2) - axial_wid
            line_end_y = ((soulman_y + virtuoso_y) / 2) - axial_hei
            can.line(line_end_x, line_end_y, soulman_x, soulman_y)
            # Вычисление направления линии
            dx = soulman_x - line_end_x
            dy = soulman_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = soulman_x
            arrow_tip_y = soulman_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(soulman_x, soulman_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(soulman_x, soulman_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)
        # Резидент -> Берсерк
        def resident_to_berserker():
            can.line(resident_x, resident_y, ((resident_x + berserker_x) / 2) - axial_wid, ((resident_y + berserker_y) / 2) + axial_hei)
            can.circle(((resident_x + berserker_x) / 2) - axial_wid, ((resident_y + berserker_y) / 2) + axial_hei, 2.5, stroke=0, fill=1)
            can.line(((resident_x + berserker_x) / 2) - axial_wid, ((resident_y + berserker_y) / 2) + axial_hei, ((resident_x + berserker_x) / 2) + axial_wid, ((resident_y + berserker_y) / 2) + axial_hei)
            can.circle(((resident_x + berserker_x) / 2) + axial_wid, ((resident_y + berserker_y) / 2) + axial_hei, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((resident_x + berserker_x) / 2) + axial_wid
            line_end_y = ((resident_y + berserker_y) / 2) + axial_hei
            can.line(line_end_x, line_end_y, berserker_x, berserker_y)
            # Вычисление направления линии
            dx = berserker_x - line_end_x
            dy = berserker_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = berserker_x
            arrow_tip_y = berserker_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(berserker_x, berserker_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(berserker_x, berserker_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)
        # Берсерк -> Резидент
        def berserker_to_resident():
            can.line(berserker_x, berserker_y, ((resident_x + berserker_x) / 2) + axial_wid, ((resident_y + berserker_y) / 2) - axial_hei)
            can.circle(((resident_x + berserker_x) / 2) + axial_wid, ((resident_y + berserker_y) / 2) - axial_hei, 2.5, stroke=0, fill=1)
            can.line(((resident_x + berserker_x) / 2) + axial_wid, ((resident_y + berserker_y) / 2) - axial_hei, ((resident_x + berserker_x) / 2) - axial_wid, ((resident_y + berserker_y) / 2) - axial_hei)
            can.circle(((resident_x + berserker_x) / 2) - axial_wid, ((resident_y + berserker_y) / 2) - axial_hei, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((resident_x + berserker_x) / 2) - axial_wid
            line_end_y = ((resident_y + berserker_y) / 2) - axial_hei
            can.line(line_end_x, line_end_y, resident_x, resident_y)
            # Вычисление направления линии
            dx = resident_x - line_end_x
            dy = resident_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = resident_x
            arrow_tip_y = resident_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(resident_x, resident_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(resident_x, resident_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)
        # Душа-человек -> Резидент
        def soulman_to_resident():
            can.line(soulman_x, soulman_y, ((soulman_x + resident_x) / 2) - axial_hei, ((soulman_y + resident_y) / 2) + axial_wid)
            can.circle(((soulman_x + resident_x) / 2) - axial_hei, ((soulman_y + resident_y) / 2) + axial_wid, 2.5, stroke=0, fill=1)
            can.line(((soulman_x + resident_x) / 2) - axial_hei, ((soulman_y + resident_y) / 2) + axial_wid, ((soulman_x + resident_x) / 2) - axial_hei, ((soulman_y + resident_y) / 2) - axial_wid)
            can.circle(((soulman_x + resident_x) / 2) - axial_hei, ((soulman_y + resident_y) / 2) - axial_wid, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((soulman_x + resident_x) / 2) - axial_hei
            line_end_y = ((soulman_y + resident_y) / 2) - axial_wid
            can.line(line_end_x, line_end_y, resident_x, resident_y)
            # Вычисление направления линии
            dx = resident_x - line_end_x
            dy = resident_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = resident_x
            arrow_tip_y = resident_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(resident_x, resident_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(resident_x, resident_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)
        # Резидент -> Душа-человек
        def resident_to_soulman():
            can.line(resident_x, resident_y, ((soulman_x + resident_x) / 2) + axial_hei, ((soulman_y + resident_y) / 2) - axial_wid)
            can.circle(((soulman_x + resident_x) / 2) + axial_hei, ((soulman_y + resident_y) / 2) - axial_wid, 2.5, stroke=0, fill=1)
            can.line(((soulman_x + resident_x) / 2) + axial_hei, ((soulman_y + resident_y) / 2) - axial_wid, ((soulman_x + resident_x) / 2) + axial_hei, ((soulman_y + resident_y) / 2) + axial_wid)
            can.circle(((soulman_x + resident_x) / 2) + axial_hei, ((soulman_y + resident_y) / 2) + axial_wid, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((soulman_x + resident_x) / 2) + axial_hei
            line_end_y = ((soulman_y + resident_y) / 2) + axial_wid
            can.line(line_end_x, line_end_y, soulman_x, soulman_y)
            # Вычисление направления линии
            dx = soulman_x - line_end_x
            dy = soulman_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = soulman_x
            arrow_tip_y = soulman_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(soulman_x, soulman_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(soulman_x, soulman_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)
        # Виртуоз -> Берсерк
        def virtuoso_to_berserker():
            can.line(virtuoso_x, virtuoso_y, ((virtuoso_x + berserker_x) / 2) - axial_hei, ((virtuoso_y + berserker_y) / 2) + axial_wid)
            can.circle(((virtuoso_x + berserker_x) / 2) - axial_hei, ((virtuoso_y + berserker_y) / 2) + axial_wid, 2.5, stroke=0, fill=1)
            can.line(((virtuoso_x + berserker_x) / 2) - axial_hei, ((virtuoso_y + berserker_y) / 2) + axial_wid, ((virtuoso_x + berserker_x) / 2) - axial_hei, ((virtuoso_y + berserker_y) / 2) - axial_wid)
            can.circle(((virtuoso_x + berserker_x) / 2) - axial_hei, ((virtuoso_y + berserker_y) / 2) - axial_wid, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((virtuoso_x + berserker_x) / 2) - axial_hei
            line_end_y = ((virtuoso_y + berserker_y) / 2) - axial_wid
            can.line(line_end_x, line_end_y, berserker_x, berserker_y)
            # Вычисление направления линии
            dx = berserker_x - line_end_x
            dy = berserker_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = berserker_x
            arrow_tip_y = berserker_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(berserker_x, berserker_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(berserker_x, berserker_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)
        # Берсерк -> Виртуоз
        def berserker_to_virtuoso():
            can.line(berserker_x, berserker_y, ((virtuoso_x + berserker_x) / 2) + axial_hei, ((virtuoso_y + berserker_y) / 2) - axial_wid)
            can.circle(((virtuoso_x + berserker_x) / 2) + axial_hei, ((virtuoso_y + berserker_y) / 2) - axial_wid, 2.5, stroke=0, fill=1)
            can.line(((virtuoso_x + berserker_x) / 2) + axial_hei, ((virtuoso_y + berserker_y) / 2) - axial_wid, ((virtuoso_x + berserker_x) / 2) + axial_hei, ((virtuoso_y + berserker_y) / 2) + axial_wid)
            can.circle(((virtuoso_x + berserker_x) / 2) + axial_hei, ((virtuoso_y + berserker_y) / 2) + axial_wid, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((virtuoso_x + berserker_x) / 2) + axial_hei
            line_end_y = ((virtuoso_y + berserker_y) / 2) + axial_wid
            can.line(line_end_x, line_end_y, virtuoso_x, virtuoso_y)
            # Вычисление направления линии
            dx = virtuoso_x - line_end_x
            dy = virtuoso_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = virtuoso_x
            arrow_tip_y = virtuoso_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(virtuoso_x, virtuoso_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(virtuoso_x, virtuoso_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)
        # Душа-человек -> Политик
        def soulman_to_politician():
            can.line(soulman_x, soulman_y, ((soulman_x + politician_x) / 2) - diagSmall_wid + diagSmall_hei, ((soulman_y + politician_y) / 2) + diagSmall_wid)
            can.circle(((soulman_x + politician_x) / 2) - diagSmall_wid + diagSmall_hei, ((soulman_y + politician_y) / 2) + diagSmall_wid, 2.5, stroke=0, fill=1)
            can.line(((soulman_x + politician_x) / 2) - diagSmall_wid + diagSmall_hei, ((soulman_y + politician_y) / 2) + diagSmall_wid, ((soulman_x + politician_x) / 2) + diagSmall_wid, ((soulman_y + politician_y) / 2) - diagSmall_wid + diagSmall_hei)
            can.circle(((soulman_x + politician_x) / 2) + diagSmall_wid, ((soulman_y + politician_y) / 2) - diagSmall_wid + diagSmall_hei, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((soulman_x + politician_x) / 2) + diagSmall_wid
            line_end_y = ((soulman_y + politician_y) / 2) - diagSmall_wid + diagSmall_hei
            can.line(line_end_x, line_end_y, politician_x, politician_y)
            # Вычисление направления линии
            dx = politician_x - line_end_x
            dy = politician_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = politician_x
            arrow_tip_y = politician_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(politician_x, politician_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(politician_x, politician_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)
        # Политик -> Душа-человек
        def politician_to_soulman():
            can.line(politician_x, politician_y, ((soulman_x + politician_x) / 2) + diagSmall_wid - diagSmall_hei, ((soulman_y + politician_y) / 2) - diagSmall_wid)
            can.circle(((soulman_x + politician_x) / 2) + diagSmall_wid - diagSmall_hei, ((soulman_y + politician_y) / 2) - diagSmall_wid, 2.5, stroke=0, fill=1)
            can.line(((soulman_x + politician_x) / 2) + diagSmall_wid - diagSmall_hei, ((soulman_y + politician_y) / 2) - diagSmall_wid, ((soulman_x + politician_x) / 2) - diagSmall_wid, ((soulman_y + politician_y) / 2) + diagSmall_wid - diagSmall_hei)
            can.circle(((soulman_x + politician_x) / 2) - diagSmall_wid, ((soulman_y + politician_y) / 2) + diagSmall_wid - diagSmall_hei, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((soulman_x + politician_x) / 2) - diagSmall_wid
            line_end_y = ((soulman_y + politician_y) / 2) + diagSmall_wid - diagSmall_hei
            can.line(line_end_x, line_end_y, soulman_x, soulman_y)
            # Вычисление направления линии
            dx = soulman_x - line_end_x
            dy = soulman_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = soulman_x
            arrow_tip_y = soulman_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(soulman_x, soulman_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(soulman_x, soulman_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)
        # Политик -> Берсерк
        def politician_to_berserker():
            can.line(politician_x, politician_y, ((politician_x + berserker_x) / 2) - diagSmall_wid + diagSmall_hei, ((politician_y + berserker_y) / 2) + diagSmall_wid)
            can.circle(((politician_x + berserker_x) / 2) - diagSmall_wid + diagSmall_hei, ((politician_y + berserker_y) / 2) + diagSmall_wid, 2.5, stroke=0, fill=1)
            can.line(((politician_x + berserker_x) / 2) - diagSmall_wid + diagSmall_hei, ((politician_y + berserker_y) / 2) + diagSmall_wid, ((politician_x + berserker_x) / 2) + diagSmall_wid, ((politician_y + berserker_y) / 2) - diagSmall_wid + diagSmall_hei)
            can.circle(((politician_x + berserker_x) / 2) + diagSmall_wid, ((politician_y + berserker_y) / 2) - diagSmall_wid + diagSmall_hei, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((politician_x + berserker_x) / 2) + diagSmall_wid
            line_end_y = ((politician_y + berserker_y) / 2) - diagSmall_wid + diagSmall_hei
            can.line(line_end_x, line_end_y, berserker_x, berserker_y)
            # Вычисление направления линии
            dx = berserker_x - line_end_x
            dy = berserker_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = berserker_x
            arrow_tip_y = berserker_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(berserker_x, berserker_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(berserker_x, berserker_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)
        # Берсерк -> Политик
        def berserker_to_politician():
            can.line(berserker_x, berserker_y, ((politician_x + berserker_x) / 2) + diagSmall_wid - diagSmall_hei, ((politician_y + berserker_y) / 2) - diagSmall_wid)
            can.circle(((politician_x + berserker_x) / 2) + diagSmall_wid - diagSmall_hei, ((politician_y + berserker_y) / 2) - diagSmall_wid, 2.5, stroke=0, fill=1)
            can.line(((politician_x + berserker_x) / 2) + diagSmall_wid - diagSmall_hei, ((politician_y + berserker_y) / 2) - diagSmall_wid, ((politician_x + berserker_x) / 2) - diagSmall_wid, ((politician_y + berserker_y) / 2) + diagSmall_wid - diagSmall_hei)
            can.circle(((politician_x + berserker_x) / 2) - diagSmall_wid, ((politician_y + berserker_y) / 2) + diagSmall_wid - diagSmall_hei, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((politician_x + berserker_x) / 2) - diagSmall_wid
            line_end_y = ((politician_y + berserker_y) / 2) + diagSmall_wid - diagSmall_hei
            can.line(line_end_x, line_end_y, politician_x, politician_y)
            # Вычисление направления линии
            dx = politician_x - line_end_x
            dy = politician_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = politician_x
            arrow_tip_y = politician_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(politician_x, politician_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(politician_x, politician_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)
        # Резидент -> Политик
        def resident_to_politician():
            can.line(resident_x, resident_y, ((resident_x + politician_x) / 2) - diagSmall_wid, ((resident_y + politician_y) / 2) - diagSmall_wid + diagSmall_hei)
            can.circle(((resident_x + politician_x) / 2) - diagSmall_wid, ((resident_y + politician_y) / 2) - diagSmall_wid + diagSmall_hei, 2.5, stroke=0, fill=1)
            can.line(((resident_x + politician_x) / 2) - diagSmall_wid, ((resident_y + politician_y) / 2) - diagSmall_wid + diagSmall_hei, ((resident_x + politician_x) / 2) + diagSmall_wid - diagSmall_hei, ((resident_y + politician_y) / 2) + diagSmall_wid)
            can.circle(((resident_x + politician_x) / 2) + diagSmall_wid - diagSmall_hei, ((resident_y + politician_y) / 2) + diagSmall_wid, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((resident_x + politician_x) / 2) + diagSmall_wid - diagSmall_hei
            line_end_y = ((resident_y + politician_y) / 2) + diagSmall_wid
            can.line(line_end_x, line_end_y, politician_x, politician_y)
            # Вычисление направления линии
            dx = politician_x - line_end_x
            dy = politician_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = politician_x
            arrow_tip_y = politician_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(politician_x, politician_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(politician_x, politician_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)
        # Политик -> Резидент
        def politician_to_resident():
            can.line(politician_x, politician_y, ((resident_x + politician_x) / 2) + diagSmall_wid, ((resident_y + politician_y) / 2) + diagSmall_wid - diagSmall_hei)
            can.circle(((resident_x + politician_x) / 2) + diagSmall_wid, ((resident_y + politician_y) / 2) + diagSmall_wid - diagSmall_hei, 2.5, stroke=0, fill=1)
            can.line(((resident_x + politician_x) / 2) + diagSmall_wid, ((resident_y + politician_y) / 2) + diagSmall_wid - diagSmall_hei, ((resident_x + politician_x) / 2) - diagSmall_wid + diagSmall_hei, ((resident_y + politician_y) / 2) - diagSmall_wid)
            can.circle(((resident_x + politician_x) / 2) - diagSmall_wid + diagSmall_hei, ((resident_y + politician_y) / 2) - diagSmall_wid, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((resident_x + politician_x) / 2) - diagSmall_wid + diagSmall_hei
            line_end_y = ((resident_y + politician_y) / 2) - diagSmall_wid
            can.line(line_end_x, line_end_y, resident_x, resident_y)
            # Вычисление направления линии
            dx = resident_x - line_end_x
            dy = resident_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = resident_x
            arrow_tip_y = resident_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(resident_x, resident_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(resident_x, resident_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)
        # Политик -> Виртуоз
        def politician_to_virtuoso():
            can.line(politician_x, politician_y, ((virtuoso_x + politician_x) / 2) - diagSmall_wid, ((virtuoso_y + politician_y) / 2) - diagSmall_wid + diagSmall_hei)
            can.circle(((virtuoso_x + politician_x) / 2) - diagSmall_wid, ((virtuoso_y + politician_y) / 2) - diagSmall_wid + diagSmall_hei, 2.5, stroke=0, fill=1)
            can.line(((virtuoso_x + politician_x) / 2) - diagSmall_wid, ((virtuoso_y + politician_y) / 2) - diagSmall_wid + diagSmall_hei, ((virtuoso_x + politician_x) / 2) + diagSmall_wid - diagSmall_hei, ((virtuoso_y + politician_y) / 2) + diagSmall_wid)
            can.circle(((virtuoso_x + politician_x) / 2) + diagSmall_wid - diagSmall_hei, ((virtuoso_y + politician_y) / 2) + diagSmall_wid, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((virtuoso_x + politician_x) / 2) + diagSmall_wid - diagSmall_hei
            line_end_y = ((virtuoso_y + politician_y) / 2) + diagSmall_wid
            can.line(line_end_x, line_end_y, virtuoso_x, virtuoso_y)
            # Вычисление направления линии
            dx = virtuoso_x - line_end_x
            dy = virtuoso_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = virtuoso_x
            arrow_tip_y = virtuoso_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(virtuoso_x, virtuoso_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(virtuoso_x, virtuoso_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)
        # Виртуоз -> Политик
        def virtuoso_to_politician():
            can.line(virtuoso_x, virtuoso_y, ((virtuoso_x + politician_x) / 2) + diagSmall_wid, ((virtuoso_y + politician_y) / 2) + diagSmall_wid - diagSmall_hei)
            can.circle(((virtuoso_x + politician_x) / 2) + diagSmall_wid, ((virtuoso_y + politician_y) / 2) + diagSmall_wid - diagSmall_hei, 2.5, stroke=0, fill=1)
            can.line(((virtuoso_x + politician_x) / 2) - diagSmall_wid + diagSmall_hei, ((virtuoso_y + politician_y) / 2) - diagSmall_wid, ((virtuoso_x + politician_x) / 2) + diagSmall_wid, ((virtuoso_y + politician_y) / 2) + diagSmall_wid - diagSmall_hei)
            can.circle(((virtuoso_x + politician_x) / 2) - diagSmall_wid + diagSmall_hei, ((virtuoso_y + politician_y) / 2) - diagSmall_wid, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((virtuoso_x + politician_x) / 2) - diagSmall_wid + diagSmall_hei
            line_end_y = ((virtuoso_y + politician_y) / 2) - diagSmall_wid
            can.line(line_end_x, line_end_y, politician_x, politician_y)
            # Вычисление направления линии
            dx = politician_x - line_end_x
            dy = politician_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = politician_x
            arrow_tip_y = politician_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(politician_x, politician_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(politician_x, politician_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)
        # Душа-человек -> Берсерк
        def soulman_to_berserker():
            can.line(soulman_x, soulman_y, ((soulman_x + berserker_x) / 2) - diagBig_wid + diagBig_hei, ((soulman_y + berserker_y) / 2) + diagBig_wid)
            can.circle(((soulman_x + berserker_x) / 2) - diagBig_wid + diagBig_hei, ((soulman_y + berserker_y) / 2) + diagBig_wid, 2.5, stroke=0, fill=1)
            can.line(((soulman_x + berserker_x) / 2) - diagBig_wid + diagBig_hei, ((soulman_y + berserker_y) / 2) + diagBig_wid, ((soulman_x + berserker_x) / 2) + diagBig_wid, ((soulman_y + berserker_y) / 2) - diagBig_wid + diagBig_hei)
            can.circle(((soulman_x + berserker_x) / 2) + diagBig_wid, ((soulman_y + berserker_y) / 2) - diagBig_wid + diagBig_hei, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((soulman_x + berserker_x) / 2) + diagBig_wid
            line_end_y = ((soulman_y + berserker_y) / 2) - diagBig_wid + diagBig_hei
            can.line(line_end_x, line_end_y, berserker_x, berserker_y)
            # Вычисление направления линии
            dx = berserker_x - line_end_x
            dy = berserker_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = berserker_x
            arrow_tip_y = berserker_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(berserker_x, berserker_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(berserker_x, berserker_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)
        # Берсерк -> Душа-человек
        def berserker_to_soulman():
            can.line(berserker_x, berserker_y, ((soulman_x + berserker_x) / 2) + diagBig_wid - diagBig_hei, ((soulman_y + berserker_y) / 2) - diagBig_wid)
            can.circle(((soulman_x + berserker_x) / 2) + diagBig_wid - diagBig_hei, ((soulman_y + berserker_y) / 2) - diagBig_wid, 2.5, stroke=0, fill=1)
            can.line(((soulman_x + berserker_x) / 2) + diagBig_wid - diagBig_hei, ((soulman_y + berserker_y) / 2) - diagBig_wid, ((soulman_x + berserker_x) / 2) - diagBig_wid, ((soulman_y + berserker_y) / 2) + diagBig_wid - diagBig_hei)
            can.circle(((soulman_x + berserker_x) / 2) - diagBig_wid, ((soulman_y + berserker_y) / 2) + diagBig_wid - diagBig_hei, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((soulman_x + berserker_x) / 2) - diagBig_wid
            line_end_y = ((soulman_y + berserker_y) / 2) + diagBig_wid - diagBig_hei
            can.line(line_end_x, line_end_y, soulman_x, soulman_y)
            # Вычисление направления линии
            dx = soulman_x - line_end_x
            dy = soulman_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = soulman_x
            arrow_tip_y = soulman_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(soulman_x, soulman_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(soulman_x, soulman_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)
        # Резидент -> Виртуоз
        def resident_to_virtuoso():
            can.line(resident_x, resident_y, ((virtuoso_x + resident_x) / 2) - diagBig_wid, ((virtuoso_y + resident_y) / 2) - diagBig_wid + diagBig_hei)
            can.circle(((virtuoso_x + resident_x) / 2) - diagBig_wid, ((virtuoso_y + resident_y) / 2) - diagBig_wid + diagBig_hei, 2.5, stroke=0, fill=1)
            can.line(((virtuoso_x + resident_x) / 2) - diagBig_wid, ((virtuoso_y + resident_y) / 2) - diagBig_wid + diagBig_hei, ((virtuoso_x + resident_x) / 2) + diagBig_wid - diagBig_hei, ((virtuoso_y + resident_y) / 2) + diagBig_wid)
            can.circle(((virtuoso_x + resident_x) / 2) + diagBig_wid - diagBig_hei, ((virtuoso_y + resident_y) / 2) + diagBig_wid, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((virtuoso_x + resident_x) / 2) + diagBig_wid - diagBig_hei
            line_end_y = ((virtuoso_y + resident_y) / 2) + diagBig_wid
            can.line(line_end_x, line_end_y, virtuoso_x, virtuoso_y)
            # Вычисление направления линии
            dx = virtuoso_x - line_end_x
            dy = virtuoso_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = virtuoso_x
            arrow_tip_y = virtuoso_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(virtuoso_x, virtuoso_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(virtuoso_x, virtuoso_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)
        # Виртуоз -> Резидент
        def virtuoso_to_resident():
            can.line(virtuoso_x, virtuoso_y, ((virtuoso_x + resident_x) / 2) + diagBig_wid, ((virtuoso_y + resident_y) / 2) + diagBig_wid - diagBig_hei)
            can.circle(((virtuoso_x + resident_x) / 2) + diagBig_wid, ((virtuoso_y + resident_y) / 2) + diagBig_wid - diagBig_hei, 2.5, stroke=0, fill=1)
            can.line(((virtuoso_x + resident_x) / 2) - diagBig_wid + diagBig_hei, ((virtuoso_y + resident_y) / 2) - diagBig_wid, ((virtuoso_x + resident_x) / 2) + diagBig_wid, ((virtuoso_y + resident_y) / 2) + diagBig_wid - diagBig_hei)
            can.circle(((virtuoso_x + resident_x) / 2) - diagBig_wid + diagBig_hei, ((virtuoso_y + resident_y) / 2) - diagBig_wid, 2.5, stroke=0, fill=1)
            # Координаты конца третьей линии
            line_end_x = ((virtuoso_x + resident_x) / 2) - diagBig_wid + diagBig_hei
            line_end_y = ((virtuoso_y + resident_y) / 2) - diagBig_wid
            can.line(line_end_x, line_end_y, resident_x, resident_y)
            # Вычисление направления линии
            dx = resident_x - line_end_x
            dy = resident_y - line_end_y
            line_length = math.hypot(dx, dy)
            # Нормализация векторов
            if line_length != 0:
                dx /= line_length
                dy /= line_length
            # Вычисление координат оконечника
            arrow_tip_x = resident_x
            arrow_tip_y = resident_y
            left_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(arrow_angle) + dy * math.sin(arrow_angle))
            left_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(arrow_angle) - dx * math.sin(arrow_angle))
            right_wing_x = arrow_tip_x - arrow_length * (dx * math.cos(-arrow_angle) + dy * math.sin(-arrow_angle))
            right_wing_y = arrow_tip_y - arrow_length * (dy * math.cos(-arrow_angle) - dx * math.sin(-arrow_angle))
            # Рисуем оконечник стрелки
            can.line(resident_x, resident_y, left_wing_x, left_wing_y)
            can.circle(left_wing_x, left_wing_y, 2.5, stroke=0, fill=1)
            can.line(resident_x, resident_y, right_wing_x, right_wing_y)
            can.circle(right_wing_x, right_wing_y, 2.5, stroke=0, fill=1)
            can.line(left_wing_x, left_wing_y, right_wing_x, right_wing_y)
        # Сортировка переменных из второго блока
        def sort_variables_2(adaptation_2, compromise_2, threat_2, cooperation_2, avoidance_2):
            # Собираем переменные в словарь
            variables = {
                'soulman': adaptation_2,
                'politician': compromise_2,
                'berserker': threat_2,
                'virtuoso': cooperation_2,
                'resident': avoidance_2
            }
            # Сортируем ключи по значениям в порядке убывания
            sorted_keys_2 = sorted(variables, key=variables.get, reverse=True)
            return sorted_keys_2, variables
        # Пример вызова функции
        sorted_result, variables = sort_variables_2(adaptation_2, compromise_2, threat_2, cooperation_2, avoidance_2)
        # Проверяем переходы между значениями
        transitions = [
            (sorted_result[0], sorted_result[1]),
            (sorted_result[1], sorted_result[2]),
            (sorted_result[2], sorted_result[3]),
            (sorted_result[3], sorted_result[4]),
        ]
        # Цикл для перебора пар значений
        for pair in transitions:
            first, second = pair  # Разделяем пару на переменные
            # В зависимости от значений переменных вызываем разные функции
            if first == 'soulman' and second == 'virtuoso':
                soulman_to_virtuoso()
            if first == 'virtuoso' and second == 'soulman':
                virtuoso_to_soulman()
            if first == 'resident' and second == 'berserker':
                resident_to_berserker()
            if first == 'berserker' and second == 'resident':
                berserker_to_resident()
            if first == 'soulman' and second == 'resident':
                soulman_to_resident()
            if first == 'resident' and second == 'soulman':
                resident_to_soulman()
            if first == 'virtuoso' and second == 'berserker':
                virtuoso_to_berserker()
            if first == 'berserker' and second == 'virtuoso':
                berserker_to_virtuoso()
            if first == 'soulman' and second == 'politician':
                soulman_to_politician()
            if first == 'politician' and second == 'soulman':
                politician_to_soulman()
            if first == 'politician' and second == 'berserker':
                politician_to_berserker()
            if first == 'berserker' and second == 'politician':
                berserker_to_politician()
            if first == 'resident' and second == 'politician':
                resident_to_politician()
            if first == 'politician' and second == 'resident':
                politician_to_resident()
            if first == 'politician' and second == 'virtuoso':
                politician_to_virtuoso()
            if first == 'virtuoso' and second == 'politician':
                virtuoso_to_politician()
            if first == 'soulman' and second == 'berserker':
                soulman_to_berserker()
            if first == 'berserker' and second == 'soulman':
                berserker_to_soulman()
            if first == 'resident' and second == 'virtuoso':
                resident_to_virtuoso()
            if first == 'virtuoso' and second == 'resident':
                virtuoso_to_resident()
        can.showPage()  # Завершение пятой страницы


        # СТРАНИЦА 6
        image_path_6 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_6.png")
        if not os.path.exists(image_path_6):
            print(f"Изображение {image_path_6} не найдено.")
            return
        can.drawImage(image_path_6, 0, 0, width=width, height=height)
        can.setFont("Bahnschrift", 14)  # Устанавливаем шрифт и размер
        if adaptation_2 is not None:
            rangeResultHorizontal(adaptation_2, 62.242, 532.995, 406.29, 36)
        if compromise_2 is not None:
            rangeResultHorizontal(compromise_2, 62.242, 532.995, 763.228, 36)
        can.showPage()  # Завершение шестой страницы


        # СТРАНИЦА 7
        image_path_7 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_7.png")
        if not os.path.exists(image_path_7):
            print(f"Изображение {image_path_7} не найдено.")
            return
        can.drawImage(image_path_7, 0, 0, width=width, height=height)
        if threat_2 is not None:
            rangeResultHorizontal(threat_2, 62.242, 532.995, 372.274, 36)
        if cooperation_2 is not None:
            rangeResultHorizontal(cooperation_2, 62.242, 532.995, 759.969, 36)
        can.showPage()  # Завершение седьмой страницы


        # СТРАНИЦА 8
        image_path_8 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_8.png")
        if not os.path.exists(image_path_8):
            print(f"Изображение {image_path_8} не найдено.")
            return
        can.drawImage(image_path_8, 0, 0, width=width, height=height)
        if avoidance_2 is not None:
            rangeResultHorizontal(avoidance_2, 62.242, 532.995, 405.865, 36)
        can.showPage()  # Завершение восьмой страницы


        # СТРАНИЦА 9
        image_path_9 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_9.png")
        if not os.path.exists(image_path_9):
            print(f"Изображение {image_path_9} не найдено.")
            return
        can.drawImage(image_path_9, 0, 0, width=width, height=height)
        can.setFont("Bahnschrift", 14)  # Устанавливаем шрифт и размер
        # Вычленяем значения из sorted_result[0] и sorted_result[4] для подсчёта разницы между минимумом и максимумом
        value_2_highest = variables[sorted_result[0]]
        value_2_lowest = variables[sorted_result[4]]
        value_2_subtraction = value_2_highest - value_2_lowest
        if value_2_subtraction < 10:
            can.drawString(257, height - 407.777, str(" " + str(value_2_subtraction)))  # Печатаем текст
        else:
            can.drawString(257, height - 407.777, str(value_2_subtraction))  # Печатаем текст
        can.showPage()  # Завершение девятой страницы

        
        # СТРАНИЦА 10
        image_path_10 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_10.png")
        if not os.path.exists(image_path_10):
            print(f"Изображение {image_path_10} не найдено.")
            return
        can.drawImage(image_path_10, 0, 0, width=width, height=height)
            # Функция рисования личного результата на вертикальной шкале
        def rangeResultVertical(range_name, range_y_start, range_y_end, range_x_start, range_divisionsCount):
            # Вычисляем координаты Y для "палочки"
            y_start = height - (range_y_start + (((range_y_end - range_y_start) / range_divisionsCount) * range_name))
            x_start = range_x_start
            yTop = 4
            yBottom = -4
            xLeft = -20
            xCenter = -16
            xRight = -12
            # Рисуем круг диаметром 1 пункт
            can.setFillColorRGB(0, 0, 0) # Устанавливаем цвет заливки (черный)
            circle_radius = 0.5  # Радиус круга в пунктах
            can.circle(x_start, y_start, circle_radius, stroke=0, fill=1)  # Рисуем круг
            # Рисуем "палочку"
            can.setStrokeColorRGB(0, 0, 0)  # Устанавливаем цвет линии (черный)
            can.setLineWidth(1)  # Устанавливаем ширину линии
            # Рисуем линию (палочку)
            can.line(x_start, y_start, x_start + xRight, y_start)
            # Рисуем остальные элементы
            can.line(x_start + xRight, y_start, x_start + xCenter, y_start + yBottom)
            can.circle(x_start + xCenter, y_start + yBottom, circle_radius, stroke=0, fill=1)
            can.line(x_start + xCenter, y_start + yBottom, x_start + xLeft, y_start)
            can.circle(x_start + xLeft, y_start, circle_radius, stroke=0, fill=1)
            can.line(x_start + xLeft, y_start, x_start + xCenter, y_start + yTop)
            can.circle(x_start + xCenter, y_start + yTop, circle_radius, stroke=0, fill=1)
            can.line(x_start + xCenter, y_start + yTop, x_start + xRight, y_start)
        if adaptation_3 is not None:
            rangeResultVertical(adaptation_3, 779.91, 312.05, 391.33, 27)
        if threat_3 is not None:
            rangeResultVertical(threat_3, 779.91, 312.05, 455.11, 27)
        if cooperation_3 is not None:
            rangeResultVertical(cooperation_3, 779.91, 312.05, 518.889, 27)
        can.showPage()  # Завершение десятой страницы


        # СТРАНИЦА 11
        image_path_11 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_11.png")
        if not os.path.exists(image_path_11):
            print(f"Изображение {image_path_11} не найдено.")
            return
        can.drawImage(image_path_11, 0, 0, width=width, height=height)
        can.showPage()  # Завершение одиннадцатой страницы


        # СТРАНИЦА 12
        image_path_12 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_12.png")
        if not os.path.exists(image_path_12):
            print(f"Изображение {image_path_12} не найдено.")
            return
        can.drawImage(image_path_12, 0, 0, width=width, height=height)
        can.showPage()  # Завершение двенадцатой страницы


        # СТРАНИЦА 13
        image_path_13 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_13.png")
        if not os.path.exists(image_path_13):
            print(f"Изображение {image_path_13} не найдено.")
            return
        can.drawImage(image_path_13, 0, 0, width=width, height=height)
        can.setFont("Bahnschrift", 14)  # Устанавливаем шрифт и размер
        can.drawString(249.658, height - 254.288, str(strengthInstallation_4))  # Силовая модель
        can.drawString(231.398, height - 287.888, str(manipulationInstallation_4))  # Манипулятивная модель
        can.drawString(250.429, height - 321.496, str(negotiationsInstallation_4))  # Деловая модель
        understandingPercentage = understandingOfStyles_4 * 100 / 30
        if (understandingPercentage).is_integer():
            can.drawString(189.178, height - 355.088, f"{int(understandingPercentage)}%")  # Понимание стилей целое, выводим без десятичных
        else:
            can.drawString(189.178, height - 355.088, f"{(understandingPercentage) :.2f}%")  # Понимание стилей дробное, выводим с двумя знаками
        # Устанавливаем начальные и конечные координаты графика
        start_x_tactics = 56.693
        start_y_tactics = height - 412.522
        end_x_tactics = 538.583
        width_tactics = 44.184
        # Определяем ширину графика, которую мы будем использовать
        fullWidth_tactics = end_x_tactics - start_x_tactics
        # Определяем значения для каждой части графика
        values_tactics = [
            {"name": "Силовая", "color": (200/255, 65/255, 85/255), "value": strengthInstallation_4},
            {"name": "Манипулятивная", "color": (90/255, 127/255, 174/255), "value": manipulationInstallation_4},
            {"name": "Деловая", "color": (235/255, 188/255, 109/255), "value": negotiationsInstallation_4},
        ]
        # Начальная позиция по X для рисования в цикле for каждой части графика
        current_x_tactics = start_x_tactics
        # График
        for part_tactics in values_tactics:
            if part_tactics["value"] > 0:  # Проверяем, что значение больше 0
                # Рассчитывается ширина на основе значения
                width_tactics_value = (fullWidth_tactics * part_tactics["value"]) / sum(part["value"] for part in values_tactics)
                can.setStrokeColorRGB(*part_tactics["color"])
                can.setLineWidth(width_tactics)
                can.line(current_x_tactics, start_y_tactics, current_x_tactics + width_tactics_value, start_y_tactics)
                current_x_tactics += width_tactics_value  # Увеличиваем текущую позицию по X
        can.showPage()  # Завершение тринадцатой страницы


        # СТРАНИЦА 14
        image_path_14 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_14.png")
        if not os.path.exists(image_path_14):
            print(f"Изображение {image_path_14} не найдено.")
            return
        can.drawImage(image_path_14, 0, 0, width=width, height=height)
        can.showPage()  # Завершение четырнадцатой страницы


        # СТРАНИЦА 15
        image_path_15 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_15.png")
        if not os.path.exists(image_path_15):
            print(f"Изображение {image_path_15} не найдено.")
            return
        can.drawImage(image_path_15, 0, 0, width=width, height=height)
        can.showPage()  # Завершение пятнадцатой страницы


        # СТРАНИЦА 16
        image_path_16 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_16.png")
        if not os.path.exists(image_path_16):
            print(f"Изображение {image_path_16} не найдено.")
            return
        can.drawImage(image_path_16, 0, 0, width=width, height=height)
        if logicArgument_6 is not None:
            rangeResultHorizontal(logicArgument_6, 63.27, 532, 458.646, 30)
        if emotionsArgument_6 is not None:
            rangeResultHorizontal(emotionsArgument_6, 63.27, 532, 762.315, 30)
        can.showPage()  # Завершение шестнадцатой страницы


        # СТРАНИЦА 17
        image_path_17 = os.path.join(os.path.dirname(os.path.abspath(__file__)), "pagesPDF", "page_17.png")
        if not os.path.exists(image_path_17):
            print(f"Изображение {image_path_17} не найдено.")
            return
        can.drawImage(image_path_17, 0, 0, width=width, height=height)
        # Цвет шкал
        scale_color_red = (200/255, 65/255, 85/255)
        scale_color_blue = (90/255, 127/255, 174/255)
        def scalesIntegr(color, scale_y_height, result, total):
            # Общие параметры шкал
            csale_width = 26.701
            csale_x_start = 103.919
            csale_x_end = 527.945
            csale_filling = csale_x_start + (result / total) * (csale_x_end - csale_x_start)
            # Рисование шкалы
            can.setStrokeColor(color)
            can.setLineWidth(csale_width)
            can.line(csale_x_start, scale_y_height, csale_filling, scale_y_height)
        # Параметры шкалы "приспособление"
        scalesIntegr(scale_color_red, height-321.543, adaptationCount, 29)
        # Параметры шкалы "компромисс"
        scalesIntegr(scale_color_blue, height-360.877, compromiseCount, 17)
        # Параметры шкалы "торги"
        scalesIntegr(scale_color_red, height-400.261, biddingCount, 15)
        # Параметры шкалы "угроза"
        scalesIntegr(scale_color_blue, height-439.644, threatCount, 26)
        # Параметры шкалы "логика как аргумент"
        scalesIntegr(scale_color_red, height-479.028, logicArgumentCount, 23)
        # Параметры шкалы "эмоции как аргумент"
        scalesIntegr(scale_color_blue, height-518.412, emotionsArgumentCount, 26)
        # Параметры шкалы "понимание стилей"
        scalesIntegr(scale_color_red, height-557.795, understandingOfStyles_4, 32)
        # Параметры шкалы "установка на силу"
        scalesIntegr(scale_color_blue, height-597.179, strengthInstallationCount, 16)
        # Параметры шкалы "установка на манипуляцию"
        scalesIntegr(scale_color_red, height-636.563, manipulationInstallationCount, 16)
        # Параметры шкалы "установка на деловые переговоры"
        scalesIntegr(scale_color_blue, height-675.946, negotiationsInstallationCount, 16)
        # Параметры шкалы "сотрудничество"
        scalesIntegr(scale_color_red, height-715.330, cooperationCount, 21)
        # Параметры шкалы "избегание"
        scalesIntegr(scale_color_blue, height-754.714, avoidanceCount, 16)
        can.showPage()  # Завершение семнадцатой страницы


    # Сохранение документа
    can.save()
    print(f"PDF-файл успешно создан: {pdf_path}")

    # Запускаем таймер на удаление файла через 5 минут
    threading.Timer(300, os.remove, args=[pdf_path]).start()

    return {"message": "PDF создан успешно"}, 200